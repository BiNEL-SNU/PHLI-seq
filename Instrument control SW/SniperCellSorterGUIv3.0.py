#-------------------------------------------------------------------------------
# Name:        SniperCellSorterGUI
# Purpose: Graphical user interface (GUI) implemented version of PHLI-seq instrument control software. Able to control PHLI-seq motorized stage as well as automatic target cell finding and isolation based on target marking files generated by SniperGUI.py
#
# Author:      Amos Chungwon Lee (amoslee89@gmail.com), Jinhyun Kim(jinhyun9130@gmail.com)
#
# Created:     22-12-2014
# Latest update : 31-07-2017
# Copyright:   (c) choongchoong 2014
# Licence:     <Your License>
#-------------------------------------------------------------------------------

import wx
import os
from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont
from PIL import TiffImagePlugin
import sys
import time
import cStringIO
import LPC_ACS
import serial
import math
from numpy import matrix
import string
from GenerateTTLsignal import *

#paramter setup
DebugMode ="run mode" #"run mode", "GUI debug"
filterBF = 183718
filterG = -5342
filterB = 57668
filterUV = 118718

#function setup
def FourAxisStop():
    while (True):
        time.sleep(0.1)
        FourAxis.write('SPD\r')
        FA=FourAxis.read(100)
        if FA=='SPD 00000000, 00000000, 00000000, 00000000\n\r':
            break

def getFourAxisPos():
    FourAxis.write('POS\r')  #returned in hex form
    FAP= FourAxis.read(100)
    #print FAP;
    pos = [x.strip(",").strip() for x in FAP.split(" ") ] 
    pos_int = [int(x,16) for x in [pos[1], pos[2], pos[3], pos[4]]] #pos in integer form. slit x, slit y, filter array, slit theta respectively
    for i in range(4):
        if pos_int[i] > 0x7FFFFFFF:
            pos_int[i] -= 0x100000000
    return pos_int

def getAFpos():
    count = 0
    timeInterval = 0.05
    while (True):
        AF.write('#RP \r\n')
        AFP = AF.read(100)
        #print AFP
        if AFP[0:3] == "#PD":
            return int(AFP.split(" ")[1].strip())
        elif count * timeInterval > 5:
            print "fetal error at getAFpos"
            break;
        else:
            time.sleep(timeInterval)
            
def waitAFstop():  #this can be wrong code. it is accurate to measure velocity of stage
    count = 0
    timeInterval = 0.05
    while (True):
        AF.write('#RP \r\n')
        AFP = AF.read(100)
        #print AFP
        if AFP[0:3] == "#PD":
            break;
        elif count * timeInterval > 5:
            print "fetal error at waitAFstop"
            break;
        else:
            time.sleep(timeInterval)
            
def moveAF(rPos):
    AF.write('#MV %s\r\n'%(str(int(rPos))))
    
def moveAFabs(aPos):
    AF.write('#MVA %s\r\n'%(str(int(aPos))))
    

#communication start, homming start
if DebugMode == "run mode":
    ## open communication 
    il_2ch =serial.Serial(port='COM3',baudrate=9600, bytesize=serial.EIGHTBITS, stopbits=serial.STOPBITS_ONE,  timeout=0.1)        ## port depends on local PC environment
    AF=serial.Serial(port='COM4',baudrate=9600, bytesize=7, stopbits=serial.STOPBITS_ONE,  timeout=0.1)        ## port depends on local PC environment
    il_4ch =serial.Serial(port='COM6',baudrate=9600, bytesize=serial.EIGHTBITS, stopbits=serial.STOPBITS_ONE,  timeout=0.1)        ## port depends on local PC environment
    FourAxis = serial.Serial(port='COM5',baudrate=9600, bytesize=serial.EIGHTBITS, stopbits=serial.STOPBITS_ONE,  timeout=0.1)        ## port depends on local PC environment
    acs=LPC_ACS.ACS()                     ## ACS stage homing, Revceiver homing location should be determied (LPC_ACS.py)

    FourAxis.write('HOM XYZU '+'\r')       ## Four axis motor homing
    FourAxisStop()
    FourAxis.write('SPD ,,2000' + '\r')
    FourAxis.write('PAB ,,' + str(filterBF) +'\r') 
    

    FourAxis.write('SPD\r')
    #time.sleep(1)
    #FA= FourAxis.read(100)
    #print FA
    FourAxisStop()
    #FourAxis.write('POS\r')
    #FAP= FourAxis.read(100)
    #print FAP
    print 'Slit & LED changer motors : Homing completed'

    


scriptFlag=False

def tupleSUM(a, b):
    return tuple(map(sum, zip(a, b)));

def tupleSUB(a, b): 
# a - b
    def sub(tup):
        return tup[0] - tup[1];
    return tuple(map(sub, zip(a, b)));

def tupleMUL(a, b): 
# a * b
    def sub(tup):
        return 1.0 * tup[0] * tup[1];
    return tuple(map(sub, zip(a, b)));

def tupleDIV(a, b): 
# a / b
    def sub(tup):
        return 1.0 * tup[0] / tup[1];
    return tuple(map(sub, zip(a, b)));  

class MyGUIApp(wx.App,wx.Frame):

    def __init__(self, redirect=False, filename=None):

        ##sys.stderr.write('%s'%(Image.__version__))

        wx.App.__init__(self, redirect, filename)
        self.frame = wx.Frame(None, title='SniperSELECT GUI v3.0')
        self.panel = wx.Panel(self.frame)

        self.filename = ''
        self.dirname = ''


        self.createMenus()
        self.connectItemsWithEvents()
        self.createKeyboardShortcuts()

        self.frame.SetMenuBar(self.menuBar)

        self.fontflag=False
        self.frame.SetSize((700,830))

        self.refPtText = wx.StaticText(self.panel, -1,'Target Image', pos = (10,0))
        self.imageMagnifyBT=wx.Button(self.panel,label=u"\u002B", pos =(260,230),size = (20,20))
        self.imageMinifyBT=wx.Button(self.panel,label=u"\u2212", pos =(260,250),size = (20,20))
        self.Bind(wx.EVT_BUTTON, self.imageMinify, self.imageMinifyBT)
        self.Bind(wx.EVT_BUTTON, self.imageMagnify, self.imageMagnifyBT)

        self.refPtText = wx.StaticText(self.panel, -1,'Set New Reference Points', pos = (10,280))

        self.refbutton1=wx.Button(self.panel,label="Set Ref point 1", pos = (10,300),size = (100,20))
        self.refbutton2=wx.Button(self.panel,label="Set Ref point 2", pos = (10,330),size = (100,20))
        self.Bind(wx.EVT_BUTTON, self.SetReference1, self.refbutton1)
        self.Bind(wx.EVT_BUTTON, self.SetReference2, self.refbutton2)
##offset and offset reset
        self.offsetbutton1=wx.Button(self.panel,label="Set Offset 1", pos = (10,360),size = (100,20))
        self.offsetbutton2=wx.Button(self.panel,label="Set Offset 2", pos = (10,390),size = (100,20))
        self.Bind(wx.EVT_BUTTON, self.Setoffset1, self.offsetbutton1)
        self.Bind(wx.EVT_BUTTON, self.Setoffset2, self.offsetbutton2)

        self.OffsetResetButton=wx.Button(self.panel,label='Reset',pos=(115,360), size=(50,50))
        self.Bind(wx.EVT_BUTTON, self.OffsetReset, self.OffsetResetButton)


        self.Offsetx1, self.Offsety1, self.Offsetx2, self.Offsety2 = 0,0,0,0

        self.refPtText = wx.StaticText(self.panel, -1,'Original Reference Points', pos = (170,280))

        self.refNote1 = wx.TextCtrl(self.panel, pos = (170, 300), size=(70,20))
        self.refNote2 = wx.TextCtrl(self.panel, pos = (170, 330), size=(70,20))
        self.Ref1button=wx.Button(self.panel,label='Set',pos=(250,300), size=(50,50))
        self.Bind(wx.EVT_BUTTON, self.RefSet, self.Ref1button)


        self.BFbutton=wx.Button(self.panel,label="Bright Field", pos=(300, 10),size = (100,30))
        self.BFindex=0
        self.rBFbutton=wx.Button(self.panel,label="rBright Field", pos=(410, 10),size = (100,30))
        self.rBFindex = 0
        self.Targetbutton=wx.Button(self.panel,label="Target", pos=(560, 10),size = (100,30))
        self.Targetindex = 0
        
        self.Bind(wx.EVT_BUTTON, self.BF, self.BFbutton)
        self.Bind(wx.EVT_BUTTON, self.rBF, self.rBFbutton)
        self.Bind(wx.EVT_BUTTON, self.Target, self.Targetbutton)

        self.bfslider = wx.Slider(self.panel, -1, 50, 1, 100, pos=(300, 50), size = (100,-1), style=wx.SL_AUTOTICKS | wx.SL_LABELS)
        self.Bind(wx.EVT_SLIDER,self.bfslide,self.bfslider)
        
        self.targetslider = wx.Slider(self.panel, -1, 50, 1, 100, pos=(570, 50), size = (100,-1), style=wx.SL_AUTOTICKS | wx.SL_LABELS)
        self.Bind(wx.EVT_SLIDER,self.targetslide,self.targetslider)

        self.noteText = wx.StaticText(self.panel,-1,"Description", pos = (170,360))
        self.pathologynoteshow = wx.TextCtrl(self.panel,pos = (170,380),size = (120,20))

## Slit button

        self.slitText = wx.StaticText(self.panel,-1,"Slit Size", pos = (300, 115))
        self.slitlarger=wx.Button(self.panel,label=u"\u002B", pos =(300,140),size = (30,30))
        self.slitsmaller=wx.Button(self.panel,label=u"\u2212", pos =(330,140),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.slitminus, self.slitsmaller)
        self.Bind(wx.EVT_BUTTON, self.slitplus, self.slitlarger)
        self.slitxChk = wx.CheckBox(self.panel,-1,"x", pos = (365,140),size = (30,15))
        self.slityChk = wx.CheckBox(self.panel,-1,"y", pos = (365,155),size = (30,15))
        self.Bind(wx.EVT_CHECKBOX, self.EvtslitxChk, self.slitxChk)
        self.Bind(wx.EVT_CHECKBOX, self.EvtslityChk, self.slityChk)
        self.slitxMove = True
        self.slityMove = True
        self.slitxChk.SetValue(True)
        self.slityChk.SetValue(True)

        

##lens button


        self.lensText = wx.StaticText(self.panel,-1,"Lens number", pos = (400, 115))
        self.lens1button=wx.Button(self.panel,label="1", pos=(400, 140),size = (20,20))
        self.lens2button=wx.Button(self.panel,label="2", pos=(430, 140),size = (20,20))
        self.lens3button=wx.Button(self.panel,label="3", pos=(460, 140),size = (20,20))
        self.lens4button=wx.Button(self.panel,label="4", pos=(490, 140),size = (20,20))
        self.Bind(wx.EVT_BUTTON, self.lens1, self.lens1button)
        self.Bind(wx.EVT_BUTTON, self.lens2, self.lens2button)
        self.Bind(wx.EVT_BUTTON, self.lens3, self.lens3button)
        self.Bind(wx.EVT_BUTTON, self.lens4, self.lens4button)

##Index number text       

        self.IndexText=wx.StaticText(self.panel,-1,"Index number", pos = (170, 410))
        self.Indexbefore=wx.Button(self.panel,label=u"\u25C0", pos =(170,430),size = (30,30))
        self.Indexafter=wx.Button(self.panel,label=u"\u25B6", pos =(200,430),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.DesBefore, self.Indexbefore)
        self.Bind(wx.EVT_BUTTON, self.DesAfter, self.Indexafter)
        self.RunButton=wx.Button(self.panel,label="Run", pos=(10, 420),size = (155,40))
        self.Bind(wx.EVT_BUTTON, self.autoSorting, self.RunButton)

        self.indexSetText = wx.TextCtrl(self.panel, pos = (240, 435), size=(30,20), style=wx.TE_PROCESS_ENTER)
        self.Bind(wx.EVT_TEXT_ENTER, self.DesGotoIndex, self.indexSetText)
        self.gotoIndexButton=wx.Button(self.panel,label="Go", pos =(280,430),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.DesGotoIndex, self.gotoIndexButton)


##Sample stage Mover
        self.movexyaxis = wx.StaticText(self.panel,-1,"Sample Stage XY axis", pos=(340,350))
        self.movezaxis = wx.StaticText(self.panel,-1,"Z axis", pos=(460,350))
        self.move1up=wx.Button(self.panel,label=u"\u25B2", pos =(460,370),size = (30,30))
        self.move1down=wx.Button(self.panel,label=u"\u25BC", pos =(460,400),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.z1moveup, self.move1up)
        self.Bind(wx.EVT_BUTTON, self.z1movedown, self.move1down)
        self.Bind(wx.EVT_MOUSEWHEEL, self.z1moveWheel)
        
        self.move1left=wx.Button(self.panel,label=u"\u25C0", pos =(340,400),size = (30,30))
        self.move1right=wx.Button(self.panel,label=u"\u25B6", pos =(400,400),size = (30,30))
        self.move1up=wx.Button(self.panel,label=u"\u25B2", pos =(370,370),size = (30,30))
        self.move1down=wx.Button(self.panel,label=u"\u25BC", pos =(370,400),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.moveL, self.move1left)
        self.Bind(wx.EVT_BUTTON, self.moveR, self.move1right)
        self.Bind(wx.EVT_BUTTON, self.moveU, self.move1up)
        self.Bind(wx.EVT_BUTTON, self.moveD, self.move1down)
        self.Bind(wx.EVT_KEY_DOWN, self.onKeyPress)
##sample stage image flip
        self.HflipChk = wx.CheckBox(self.panel,-1,"Mirror Horizontal", pos = (560,380),size = (100,20))
        self.VflipChk = wx.CheckBox(self.panel,-1,"Mirror Vertical", pos = (560,400),size = (100,20))
        self.Bind(wx.EVT_CHECKBOX, self.EvtHflip, self.HflipChk)
        self.Bind(wx.EVT_CHECKBOX, self.EvtVflip, self.VflipChk)
        self.HflipFlag = False
        self.VflipFlag = False
        

        


## Moves 96 well (high throughput)
        self.well96rLabel= list(string.ascii_uppercase)[0:8]
        self.well96cLabel = range(1,13)

        self.wellplate = wx.StaticText(self.panel,-1,"96 well plate", pos = (170, 480))

        ButStartPos = (170, 500); #from left,up
        PosIncrement = (30, 30); #x: column, y: row
        ButSize = (25, 25);

        self.prevButton = "A1"
        self.curButton = "A1"
        

        for rLabel in self.well96rLabel:
            for cLabel in self.well96cLabel:
                thisLabel = rLabel + str(cLabel);
                #print thisLabel;
                rIndex = ord(rLabel) - 64;
                cIndex = cLabel;
                
                thisPosInc = (PosIncrement[0] * (cIndex - 1), PosIncrement[1] * (rIndex - 1));
                thisButPos = tupleSUM(ButStartPos, thisPosInc);
                #print thisButPos;
                
                botton = wx.Button(self.panel,label=thisLabel, pos =thisButPos,size = ButSize)
                self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, botton)




## Moving wells to wells

        self.wellleft=wx.Button(self.panel,label=u"\u25C0", pos =(560,600),size = (30,30))
        self.wellright=wx.Button(self.panel,label=u"\u25B6", pos =(620,600),size = (30,30))
        self.wellup=wx.Button(self.panel,label=u"\u25B2", pos =(590,570),size = (30,30))
        self.welldown=wx.Button(self.panel,label=u"\u25BC", pos =(590,630),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, self.wellleft)
        self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, self.wellright)
        self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, self.wellup)
        self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, self.welldown)

        self.currentwelltext = wx.StaticText(self.panel,
                                             -1,"Current Well",pos=(560,480))
        self.currentwellnote = wx.TextCtrl(self.panel, pos = (560, 510), size=(30,20))

        self.NextWellbutton=wx.Button(self.panel,label="Next Well", pos=(560,680),size = (100,30))
        self.Bind(wx.EVT_BUTTON, self.well96ButtonClick, self.NextWellbutton)

##Laser shot automation
        self.SHOTbutton=wx.Button(self.panel,label="Pulse Laser", pos=(560, 280),size = (100,30))
        self.laser=GenerateTTLsignal("Dev1/port0/line1")
        self.Bind(wx.EVT_BUTTON, self.lasershot,self.SHOTbutton)
        
        
        

# roughness
        self.Roughnesstext = wx.StaticText(self.panel,-1,"Roughness", pos=(300,180))
        list2 = ["Coarse", "Fine", "Extra Fine"]
        self.zaxischoose2 = wx.ListBox(self.panel,-1,(560,210),(80,50),list2,wx.LB_SINGLE)
        self.Bind(wx.EVT_LISTBOX, self.Roughness, self.zaxischoose2)

        self.Roslider = wx.Slider(self.panel, -1, 500, 1, 1000, pos=(310, 200), size = (200,-1), style=wx.SL_AUTOTICKS | wx.SL_LABELS)
        self.Bind(wx.EVT_SLIDER,self.Roslide,self.Roslider)
        

##        self.InsertRotext = wx.StaticText(self.panel,-1,"Insert Roughness", pos = (,180)
        self.RoSetText = wx.TextCtrl(self.panel, pos = (430, 180), size=(60,20), style=wx.TE_PROCESS_ENTER)
        self.Bind(wx.EVT_TEXT_ENTER, self.RoSet, self.RoSetText)
        
        
        
##96well stage move
##        self.movezaxis2 = wx.StaticText(self.panel,-1,"Well Number", pos=(520,50))
##        list1 = ['1','2','3','4','5','6','7','8']
##        
##        self.zaxischoose2 = wx.ListBox(self.panel,-1,(520,70),(80,100),list1,wx.LB_SINGLE)
##        self.Bind(wx.EVT_LISTBOX, self.WellSelection, self.zaxischoose2)

        self.movexyaxis2 = wx.StaticText(self.panel,-1,"96 Well stage", pos = (340, 260))
        self.movezaxis2 = wx.StaticText(self.panel,-1,"Z axis", pos=(460,260))
        self.move2up=wx.Button(self.panel,label=u"\u25B2", pos =(460,280),size = (30,30))
        self.move2down=wx.Button(self.panel,label=u"\u25BC", pos =(460,310),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.z2moveup, self.move2up)
        self.Bind(wx.EVT_BUTTON, self.z2movedown, self.move2down)


        self.move2left=wx.Button(self.panel,label=u"\u25C0", pos =(340,310),size = (30,30))
        self.move2right=wx.Button(self.panel,label=u"\u25B6", pos =(400,310),size = (30,30))
        self.move2up=wx.Button(self.panel,label=u"\u25B2", pos =(370,280),size = (30,30))
        self.move2down=wx.Button(self.panel,label=u"\u25BC", pos =(370,310),size = (30,30))
        self.Bind(wx.EVT_BUTTON, self.move2L, self.move2left)
        self.Bind(wx.EVT_BUTTON, self.move2R, self.move2right)
        self.Bind(wx.EVT_BUTTON, self.move2U, self.move2up)
        self.Bind(wx.EVT_BUTTON, self.move2D, self.move2down)

##GetPosition and Set Position
        self.getpositionbutton = wx.Button(self.panel, label = "Get Position", pos = (560, 350), size = (100,20))
        self.Bind(wx.EVT_BUTTON, self.GetPositionAll, self.getpositionbutton)
        self.setpositionbutton = wx.Button(self.panel, label = "Set Position", pos = (560, 170), size = (100,20))
        self.Bind(wx.EVT_BUTTON, self.SetInsertPosition, self.setpositionbutton)

## Retrieval and Insert Buttons
        self.RetrieveButton=wx.Button(self.panel,label="Draw", pos = (560,110),size = (100,20))
        self.InsertButton=wx.Button(self.panel,label="Insert", pos = (560,140),size = (100,20))
        self.Bind(wx.EVT_BUTTON, self.Retrieve, self.RetrieveButton)
        self.Bind(wx.EVT_BUTTON, self.Insert, self.InsertButton)
        self.stage2lock = 0
        
        self.wellindex = 1
## Flourescence filter array buttons
        self.FilterText = wx.StaticText(self.panel, -1, "Filter", pos = (410,50))
        self.filter1button=wx.Button(self.panel,label="BF", pos=(410, 70),size = (30,20))
        self.filter2button=wx.Button(self.panel,label="G", pos=(450, 70),size = (30,20))
        self.filter3button=wx.Button(self.panel,label="B", pos=(490, 70),size = (30,20))
        self.filter4button=wx.Button(self.panel,label="UV", pos=(530, 70),size = (30,20))
        self.Bind(wx.EVT_BUTTON, self.filter1, self.filter1button)
        self.Bind(wx.EVT_BUTTON, self.filter2, self.filter2button)
        self.Bind(wx.EVT_BUTTON, self.filter3, self.filter3button)
        self.Bind(wx.EVT_BUTTON, self.filter4, self.filter4button)

## initialize parameters
        self.Rough = 10
        self.Ro = 0.001*self.Rough
        self.Ro1 = 0.5*self.Rough #0.05
        self.Ro2 = 21.87*self.Rough
        self.Ro3 = 0.01*self.Rough
        self.Roslider.SetValue(self.Rough)
        self.currentwellnote.SetValue(self.curButton)
        self.curLens = 1;
        self.curAFpos = 0;
        self.flagSlide96Cap = 0; #0: slide view, 1: 96Cap view
        self.ReceiveMode = "96 caps" #"single cap", "96 caps", "96 wells"
        self.receiveMoveMode = "ordinary" #"ordinary", "fast"
        self.initStage2zNear = 23.4; 
        self.imageLeftTop = (281, 188)
        self.imageRightDown = (1210, 885)
        self.insertPosX = -2.5
        self.insertPosY = 12.54 #11.82
        self.insertPosZ = 23.62
        self.imCropSizeFactor = 3.0 #1: just target region, above : minify, below : magnify
        


        
##Initially moves the second stage
        if DebugMode == "run mode":
            acs.move(4,-2.9)  #x, -2.55
            acs.move(5,12.54)  #y, 7
            acs.move(6,23.4) #24
        
        
        self.frame.Show()




    def well96ButtonClick(self, event):
        if self.stage2lock == 1: #draw
            return;
        
        xAxisUnit = 9.009;
        yAxisUnit = 9.0214;
        
        thisLabel = event.GetEventObject().GetLabel();
        thisEvtType = event.GetEventType(); #10058 for EVT_KEY_DOWN, 10012 for EVT_BUTTON

        if (thisLabel == "Next Well") or (thisLabel == "Run") or ((thisEvtType == 10058) and (event.GetKeyCode() == 46)):
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            rIndex = ord(rLabelCur);
            cIndex = int(cLabelCur);
            if self.receiveMoveMode == "ordinary": #A1 - H1 - A2 - H2 - ...
                if rLabelCur == 'H':
                    if cIndex>=12:
                        print "96 well complete";
                    else:
                        self.prevButton = self.curButton;
                        self.curButton = 'A' + str(cIndex + 1);
                        acs.move(4, xAxisUnit);
                        acs.move(5, -7 * yAxisUnit);
                else:
                    self.prevButton = self.curButton;
                    self.curButton = chr(rIndex + 1) + cLabelCur;
                    acs.move(5, yAxisUnit);
                    
            elif self.receiveMoveMode == "fast": #A1 - H1 - H2 - A2 - ...   
                if (rLabelCur == 'H') and (cIndex>=12):
                        print "96 well complete";
                elif (cIndex % 2 == 0):
                    if (rLabelCur == 'A'):
                        self.prevButton = self.curButton;
                        self.curButton = rLabelCur + str(cIndex + 1);
                        acs.move(4, xAxisUnit);
                        #acs.move(5, -7 * yAxisUnit);
                    else:
                        self.prevButton = self.curButton;
                        self.curButton = chr(rIndex - 1) + cLabelCur;
                        acs.move(5, - yAxisUnit);   
                elif (cIndex % 2 == 1):
                    if (rLabelCur == 'H'):
                        self.prevButton = self.curButton;
                        self.curButton = rLabelCur + str(cIndex + 1);
                        acs.move(4, xAxisUnit);
                    else:
                        self.prevButton = self.curButton;
                        self.curButton = chr(rIndex + 1) + cLabelCur;
                        acs.move(5, yAxisUnit);
                else:
                    print "fetal error @ func well96ButtonClick"
            else:
                print "wrong input receiveMoveMode: " + self.receiveMoveMode
                
        elif thisLabel == u"\u25C0":
            #left
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            cIndex = int(cLabelCur);
            if cIndex <= 1:
                print "error: current Well is ", self.curButton;
            else:
                acs.move(4, - xAxisUnit);
                self.prevButton = self.curButton;
                self.curButton = rLabelCur + str(cIndex - 1);
            
        elif thisLabel == u"\u25B6":
            #right
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            cIndex = int(cLabelCur);
            if cIndex >= 12:
                print "error: current Well is ", self.curButton;
            else:
                acs.move(4, xAxisUnit);
                self.prevButton = self.curButton;
                self.curButton = rLabelCur + str(cIndex + 1);
            
        elif thisLabel == u"\u25B2":
            #up
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            rIndex = ord(rLabelCur);
            if rIndex <= 65: #A
                print "error: current Well is ", self.curButton;
            else:
                acs.move(5, - yAxisUnit);
                self.prevButton = self.curButton;
                self.curButton = chr(rIndex - 1) + cLabelCur;
            
        elif thisLabel == u"\u25BC":
            #down
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            rIndex = ord(rLabelCur);
            if rIndex >= 72: #H
                print "error: current Well is ", self.curButton;
            else:
                acs.move(5, yAxisUnit);
                self.prevButton = self.curButton;
                self.curButton = chr(rIndex + 1) + cLabelCur;
            
                   
        else: #exect well button click
            self.prevButton = self.curButton;
            self.curButton = event.GetEventObject().GetLabel();
            
    ##        print self.prevButton, self.curButton
            
            #rIndex = ord(rLabel) - 64;
            #cIndex = int(cLabel);
          
            rLabelPrev = self.prevButton[0]
            cLabelPrev = self.prevButton[1:3]
            rLabelCur = self.curButton[0]
            cLabelCur = self.curButton[1:3]
            rIndexDiff = ord(rLabelCur) - ord(rLabelPrev)
            cIndexDiff = int(cLabelCur) - int(cLabelPrev)
##            print rIndexDiff, cIndexDiff
            if rIndexDiff != 0:
                acs.move(5, yAxisUnit * rIndexDiff) #y axis
            if cIndexDiff != 0:
                acs.move(4, xAxisUnit * cIndexDiff) #x axis
                
        self.currentwellnote.SetValue(self.curButton)



    def connectItemsWithEvents(self) :
        self.Bind(wx.EVT_MENU, self.importEvent1, self.importItem1)
        self.Bind(wx.EVT_MENU, self.importEvent2, self.importItem2)


    def createKeyboardShortcuts(self) :
        self.accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL, ord('O'), self.importItem1.GetId()),
                                            (wx.ACCEL_CTRL, ord('O'), self.importItem2.GetId())])
        self.frame.SetAcceleratorTable(self.accel_tbl)

    def createMenus(self) :
        self.menuBar = wx.MenuBar()
        self.menuFile = wx.Menu()

        self.menuBar.Append(self.menuFile, '&File')
        self.importItem1 = wx.MenuItem(self.menuFile, wx.NewId(), u'&Import Item ...\tCTRL+I')
        self.importItem2 = wx.MenuItem(self.menuFile, wx.NewId(), u'&Import Picture ...\tCTRL+P')

        #self.openItem.SetBitmap(wx.Bitmap('images/document-open.png'))
        self.menuFile.AppendItem(self.importItem1)
        self.menuFile.AppendItem(self.importItem2)

    def importEvent1(self, event) :
        openDialog = wx.FileDialog(self.frame, u'Open file', "File", "", "*.*", wx.OPEN)
        if openDialog.ShowModal() == wx.ID_OK :
            self.filename = openDialog.GetFilename()
            self.dirname = openDialog.GetDirectory()


            self.coordx1 = []
            self.coordx2 = []
            self.coordy1 = []
            self.coordy2 = []
            self.pathologynote = []


            self.datafile=open(os.path.join(self.dirname, self.filename))
            self.text = []

            for line in self.datafile:
                self.text.append(line)
            for line in range(1,len(self.text)) :
                self.coordx1.append(self.text[line].split()[1])

            for line in self.datafile:
                self.text.append(line)
            for line in range(1,len(self.text)) :
                self.coordy1.append(self.text[line].split()[2])

            for line in self.datafile:
                self.text.append(line)
            for line in range(1,len(self.text)) :
                self.coordx2.append(self.text[line].split()[3])

            for line in self.datafile:
                self.text.append(line)
            for line in range(1,len(self.text)) :
                self.coordy2.append(self.text[line].split()[4])

            for line in self.datafile:
                self.text.append(line)
            for line in range(1,len(self.text)) :
                self.pathologynote.append(self.text[line].split('\t')[5])

            self.TargetNum = len(self.text) - 1; 
            self.targetPos = dict()

        openDialog.Destroy()


    def importEvent2(self, event) :
        self.index = 0
        openDialog = wx.FileDialog(self.frame, u'Open file', "File", "", "*.*", wx.OPEN)
        if openDialog.ShowModal() == wx.ID_OK :
            self.filename = openDialog.GetFilename()
            self.dirname = openDialog.GetDirectory()
            self.original2=Image.open(os.path.join(self.dirname, self.filename))
            #self.original2.save(os.path.join(self.dirname, 'copy.tif'))
            self.picture = wx.StaticBitmap(self.panel,size=(250,250),pos=(10,20))
            self.Offsetx1, self.Offsetx2, self.Offsety1, self.Offsety2 = 0,0,0,0
            self.indexSetText.SetValue(str(self.index + 1))
            self.DesMove(event);

            openDialog.Destroy()

    def piltoimage(self, pil, alpha=True):
##    """Convert PIL Image to wx.Image."""
        if alpha:
            image = apply( wx.EmptyImage, pil.size )
            image.SetData( pil.convert( "RGB").tostring() )
            image.SetAlphaData(pil.convert("RGBA").tostring()[3::4])
        else:
            image = wx.EmptyImage(pil.size[0], pil.size[1])
            new_image = pil.convert('RGB')
            data = new_image.tostring()
            image.SetData(data)
        return image


    def DesBefore(self,event):
        #self.panel.Refresh()
        ##commented out at 15.10.16 because sometime picture would dissapear
        if self.index == 0:
            print "[error] Already in First Target region"

        elif self.index > 0:
            self.index -=1
            self.indexSetText.SetValue(str(self.index + 1))
            self.DesMove(event);
        
   

    def DesAfter(self,event):
        #self.panel.Refresh()
        if self.index >= self.TargetNum - 1:
            self.index = self.TargetNum - 1;
            print "[error] Already in Last Target region"
        else:
            self.index +=1
            self.indexSetText.SetValue(str(self.index + 1))
            self.DesMove(event);

    def DesGotoIndex(self, event):
        #self.panel.Refresh()
        thisIndex = int(self.indexSetText.GetValue())
        if (thisIndex > self.TargetNum) or (thisIndex <= 0):
            print "[error] Wrong target Index"
        else:
            self.index = thisIndex - 1
            self.DesMove(event);

            
    def changeImage(self,event):
        self.distancex = int(self.coordx2[self.index])-int(self.coordx1[self.index])
        self.distancey = int(self.coordy2[self.index])-int(self.coordy1[self.index])
        centerX = (int(self.coordx2[self.index]) + int(self.coordx1[self.index])) / 2
        centerY = (int(self.coordy2[self.index]) + int(self.coordy1[self.index])) / 2
        
        self.imCropSize = int(max(self.distancex, self.distancey) * self.imCropSizeFactor / 2.0) #radius of image crop size 
        self.im= self.original2.crop((centerX - self.imCropSize, centerY - self.imCropSize, centerX + self.imCropSize, centerY + self.imCropSize)).resize((250,250))

        self.picture.SetBitmap(wx.BitmapFromImage(self.piltoimage(self.im)))
        try:self.picture = wx.StaticBitmap.Create(self,wx.BitmapFromImage(self.piltoimage(self.im)),self.panel,size=(250,250),pos=(10,20))
        except: pass

    def DesMove(self, event):
        self.changeImage(event)
        self.pathologynoteshow.SetValue(str(self.pathologynote[self.index]))

##Move automation calculation
        oldx1 = (float(self.coordx1[self.index])+float(self.coordx2[self.index]))/2
        oldy1 = (float(self.coordy1[self.index])+float(self.coordy2[self.index]))/2
        
        
        New = matrix([[self.scale*self.cosTheta, -self.scale*self.sinTheta],
                      [self.scale*self.sinTheta, self.scale*self.cosTheta]]) * matrix([[oldx1],[oldy1]]) + matrix([[self.Cx], [self.Cy]])

        (newx1,newy1)= New.item(0), New.item(1)
        

##Area calculation for slit conversion
        NewArea1 = self.Conversion(float(self.coordx1[self.index]),float(self.coordy1[self.index]))
        NewArea2 = self.Conversion(float(self.coordx2[self.index]),float(self.coordy2[self.index]))
        (newAreax1,newAreay1)= NewArea1.item(0), NewArea1.item(1)
        (newAreax2,newAreay2)= NewArea2.item(0), NewArea2.item(1)

        slity = abs(newAreax2 - newAreax1)*1000/1.5  #slit x and y is flipped
        slitx = abs(newAreay2 - newAreay1)*1000/1.5
        slitxx = int(302.81*slitx - 1191.7)
        slityy = int(302.81*slity - 1191.7)

##move
        if self.index in self.targetPos:
            thisTarget = self.targetPos[self.index]
            [targetPosX, targetPosY, targetPosZ, targetSlitX, targetSlitY] = [float(x) for x in thisTarget.split(":")] #float value
            acs.move(0, targetPosX - acs.getPosition()[0])
            acs.move(1, targetPosY - acs.getPosition()[1])
            moveAFabs(targetPosZ)
            slitxx = targetSlitX
            slityy = targetSlitY
        else:
            acs.move(0,newx1-acs.getPosition()[0]+self.Offsetx2-self.Offsetx1)
            acs.move(1,-1*(newy1+acs.getPosition()[1])+self.Offsety2-self.Offsety1)


        self.slitxABS(slitxx)
        self.slityABS(slityy)
        

    def setTargetPos(self, event):
        print "setting sniper target position of index " + str(self.index + 1)
        targetPosX = acs.getPosition()[0]
        targetPosY = acs.getPosition()[1]
        targetPosZ = getAFpos()
        faPos = getFourAxisPos()
        targetSlitX = faPos[0]  #integer value
        targetSlitY = faPos[1]
        self.targetPos[self.index] = ":".join(str(x) for x in [targetPosX, targetPosY, targetPosZ, targetSlitX, targetSlitY]) #string value
  
    def imageMinify(self, event):
        self.imCropSizeFactor *= 2.0
        self.changeImage(event)
        
    def imageMagnify(self, event):
        self.imCropSizeFactor /= 2.0
        self.changeImage(event)
        
    def autoSorting(self, event):
        time.sleep(0.5)
        self.laser.TTL()
        time.sleep(0.15); #wait until sample settles
        while 1:
            self.well96ButtonClick(event)
            self.DesAfter(event)
            acs.MotionEnd();
            FourAxisStop()
            waitAFstop()
            time.sleep(0.05)
            self.laser.TTL()
            time.sleep(0.15); #wait until sample settles
            
            if self.curButton == "H12":
                print "Finished 96 well" 
                break;
            if self.index >= self.TargetNum - 1:
                print "Finished target region" 
                break;


    def BF(self,event):
        if self.BFindex == 0:
            il_2ch.write('1ION\r\n')
            self.BFindex = 1
        elif self.BFindex ==1:
            il_2ch.write('1IOF\r\n')
            self.BFindex =0

    def bfslide(self,event):
        intensity = int(int(self.bfslider.GetValue())*5.11)
        il_2ch.write('1BRT '+str(intensity)+'\r\n')
        
    def targetslide(self, event):
        intensity = int(int(self.targetslider.GetValue())*5.11)
        il_2ch.write('2BRT '+str(intensity)+'\r\n')

    def rBF(self,event):
        if self.rBFindex == 0:
            self.LED_off()
            FourAxis.write('PAB ,,183718'+'\r')
            FourAxisStop()
            il_4ch.write('1ION\r\n')
            self.rBFindex = 1
        elif self.rBFindex ==1:
            il_4ch.write('1IOF\r\n')
            self.rBFindex = 0
            
        
    def Target(self,event):
        if self.Targetindex ==0:
            il_2ch.write('2ION\r\n')
            self.Targetindex = 1
            
        elif self.Targetindex ==1:
            il_2ch.write('2IOF\r\n')
            self.Targetindex =0
        

    def slitminus(self,event):
        pulse=-1*self.Ro2
        if(self.slityMove):
            FourAxis.write('PIC '+str(pulse)+'\r')
        if(self.slitxMove):
            FourAxis.write('PIC ,'+str(pulse)+'\r')
        FourAxisStop()

    def slitplus(self,event):
        pulse=self.Ro2
        if(self.slityMove):
            FourAxis.write('PIC '+str(pulse)+'\r')  #truncate to integer
        if(self.slitxMove):
            FourAxis.write('PIC ,'+str(pulse)+'\r')
        FourAxisStop()

    def slitx(self,x):
        FourAxis.write('PIC '+str(x)+'\r')

    def slity(self,y):
        FourAxis.write('PIC ,'+str(y)+'\r')
        
    def slitxABS(self, x):
        FourAxis.write('PAB '+str(x)+'\r')
        
    def slityABS(self, y):
        FourAxis.write('PAB ,'+str(y)+'\r')
        
    def EvtslitxChk(self, event):
        cb = event.GetEventObject()
        if cb.IsChecked():
            self.slitxMove = True
        else:
            self.slitxMove = False
        
            
    def EvtslityChk(self, event):
        cb = event.GetEventObject()
        if cb.IsChecked():
            self.slityMove = True
        else:
            self.slityMove = False
        
        
        

    def lens1(self,event):
        acs.move(2,2.8915, 'a')
        self.curLens = 1;

    def lens2(self,event):
        acs.move(2,40.9165, 'a')
        self.curLens = 2;

    def lens3(self,event):
        acs.move(2,78.9415, 'a')
        self.curLens = 3;

    def lens4(self,event):
        acs.move(2,116.9515, 'a')
        self.curLens = 4;

    def filter1(self,event):
        cmd_4A='PAB ,,' + str(filterBF) +'\r' ## BF
        FourAxis.write(cmd_4A)
        FourAxisStop()

    def filter2(self,event): 
        cmd_4A='PAB ,,' + str(filterG) +'\r' ## Green
        FourAxis.write(cmd_4A)
        FourAxisStop()

    def filter3(self,event):
        cmd_4A='PAB ,,' + str(filterB) +'\r'  ##Blue
        FourAxis.write(cmd_4A)
        FourAxisStop()

    def filter4(self,event):
        cmd_4A='PAB ,,' + str(filterUV) +'\r'  ##UV
        FourAxis.write(cmd_4A)
        FourAxisStop()

    def moveL(self,event):
        if(self.VflipFlag):
            acs.move(0,self.Ro)
        else:
            acs.move(0,-1*self.Ro)
        

    def moveR(self,event):
        if(self.VflipFlag):
            acs.move(0,-1 * self.Ro)
        else:
            acs.move(0,self.Ro)
        

    def moveU(self,event):
        if(self.HflipFlag):
            acs.move(1,self.Ro)
        else:
            acs.move(1,-1*self.Ro)
        

    def moveD(self,event):
        if(self.HflipFlag):
            acs.move(1,-1 * self.Ro)
        else:
            acs.move(1,self.Ro)

    def EvtHflip(self, event):
        cb = event.GetEventObject()
        if cb.IsChecked():
            self.HflipFlag = True
        else:
            self.HflipFlag = False
        
    def EvtVflip(self, event):
        cb = event.GetEventObject()
        if cb.IsChecked():
            self.VflipFlag = True
        else:
            self.VflipFlag = False


    def onKeyPress(self, event):
        key= event.GetKeyCode();
##        print key;
        if key == 65: #a
            self.moveL(event)
        elif key == 68: #d
            self.moveR(event)
        elif key == 87: #w
            self.moveU(event)
        elif key == 83: #s
            self.moveD(event)
        elif key == 44: #commma ,
            curFilter = getFourAxisPos()[2]
            if curFilter != filterBF:
                cmd_4A='PAB ,,' + str(filterBF) +'\r' ## BF
                FourAxis.write(cmd_4A)
                FourAxisStop()
                time.sleep(0.1)
                self.laser.TTL()
                time.sleep(0.15) #wait until the sample settles
                cmd_4A='PAB ,,' + str(curFilter) +'\r' ## BF
                FourAxis.write(cmd_4A)
                FourAxisStop()
            elif curFilter == filterBF:
                self.laser.TTL()
                time.sleep(0.15) #wait until the sample settles
            else:
                print("fetal error @ key press ,")
        elif key == 46: #dot .
            #if you want to change shortcut key, also change in well96ButtonClick function
            self.well96ButtonClick(event);
        elif key == 77: #k, move lens from sample focus to 96cap focus
            if event.ControlDown(): #Ctrl + k
                self.distSlide96Cap = 11800 #as self.Rough scale
                if self.flagSlide96Cap == 0:
                    print "move to the 96cap focus"
                    AF.write('#MV %s\r\n'%(str(int(-0.5 *12.72 * self.distSlide96Cap))))
                    time.sleep(0.5)
                    self.flagSlide96Cap = 1
                elif self.flagSlide96Cap == 1:
                    print "move to the sample focus"
                    AF.write('#MV %s\r\n'%(str(int(0.5 * 12.72 * self.distSlide96Cap))))
                    time.sleep(0.5)
                    self.flagSlide96Cap = 0
            else:
                event.Skip()
        elif key == 78: #j, move receiver from receiving mode to observing mode
            if event.ControlDown(): #Ctrl + j: set position of observing mode
                acs.getPosition2();
                stage2x, stage2y, stage2z = acs.getPosition2()
                self.initStage2zNear = stage2z;
            else:
                acs.getPosition2();
                stage2x, stage2y, stage2z = acs.getPosition2()
                acs.move(6, self.initStage2zNear - stage2z)

        elif key == 84: #t, set sniper target position
            if event.ControlDown():
                self.setTargetPos(event)
                
        elif key == 82: #r, recieve mode change: "single cap", "96 caps", "96 wells"
            if event.ControlDown(): #Ctrl + r
                if self.ReceiveMode == "single cap":
                    print "change Receive mode to 96 cap holder sorting"
                    self.ReceiveMode = "96 caps"
                elif self.ReceiveMode == "96 caps":
                    self.ReceiveMode = "single cap"
                    print "change Receive mode to single cap sorting"
            else:
                event.Skip()
            
        elif key == 49: #1 (not keypad)
            if event.ControlDown(): #Ctrl + 1: set mouse position of left top of image
                self.imageLeftTop = wx.GetMousePosition();
                print "Mouse position Set: Left Top of image"
            else:
                event.Skip()
        elif key == 50: #2 (not keypad)
            if event.ControlDown(): #Ctrl + 2: set mouse position of right bottom of image
                self.imageRightDown = wx.GetMousePosition();
                print "Mouse position Set: Right Bottom of image"
            else:
                event.Skip()
        
        elif key == 71: #g
            #!only support lens 2 yet
            stageXview = 0.436; #x axis left view to right view -> stage(axis 0) scale, 0.435, lens2
            stageYview = 0.321; #0.320
            if self.curLens == 2:
                stageView = (stageXview, stageYview);
            elif self.curLens == 1:
                stageView = (stageXview*2.0, stageYview*2.0);
            elif self.curLens == 3:
                stageView = (stageXview/2.0, stageYview/2.0);
            else:
                print "does not support such lens: " + str(self.curLens)
            curMouse = wx.GetMousePosition();
            #monitorLeftTop = (0, 0);
            #monitorRightDown = (1919, 1079);

            if (curMouse[0] > self.imageRightDown[0]) | (curMouse[0] < self.imageLeftTop[0]):
                return;
            if (curMouse[1] > self.imageRightDown[1]) | (curMouse[1] < self.imageLeftTop[1]):
                return;
            imageSize = tupleSUB(self.imageRightDown, self.imageLeftTop)
            
            imageMiddle = tuple(x/2.0 for x in tupleSUM(self.imageLeftTop, self.imageRightDown))
            imageToMove = curMouse - imageMiddle
            ratioToMove = tupleDIV(imageToMove, imageSize);
            stageToMove = list(tupleMUL(ratioToMove, stageView))
            if(self.VflipFlag):
                stageToMove[0] *= -1
            if(self.HflipFlag):
                stageToMove[1] *= -1
                
            acs.move(0, stageToMove[0])
            acs.move(1, stageToMove[1])

        elif key == 69: #increase, e
            RoStep = 5;
            self.Rough = min(int(self.Roslider.GetValue()) + RoStep, 1000)
            self.Ro = 0.001*self.Rough
            self.Ro1 = 0.5*self.Rough #0.05
            self.Ro2 = 21.87*self.Rough
            self.Ro3 = 0.01*self.Rough
            self.Roslider.SetValue(self.Rough)
        elif key == 81: #decrease, q
            RoStep = 5;
            self.Rough = max(int(self.Roslider.GetValue()) - RoStep, 1)
            self.Ro = 0.001*self.Rough
            self.Ro1 = 0.5*self.Rough #0.05
            self.Ro2 = 21.87*self.Rough
            self.Ro3 = 0.01*self.Rough
            self.Roslider.SetValue(self.Rough)
        else:
            event.Skip()
            
        

##stage2        

    def move2L(self,event):
        acs.move(4,-1*self.Ro3)
        

    def move2R(self,event):
        acs.move(4,self.Ro3)
        

    def move2U(self,event):
        acs.move(5,-1*self.Ro3)
        

    def move2D(self,event):
        acs.move(5,self.Ro3)


## Retrieve and Insert
#3 ReceiveMode modes: "single cap", "96 caps", "96 wells"
    def Insert(self,event):
        if self.ReceiveMode == "single cap":
            if self.stage2lock == 1:
                acs.move(6,15)
                acs.move(5,-30)
                
        elif self.ReceiveMode == "96 caps":
            acs.getPosition2(); #first getPosition call returns strange value (stage2x)
            stage2x, stage2y, stage2z = acs.getPosition2()
            acs.move(4, self.insertPosX - stage2x)
            acs.move(5, self.insertPosY - stage2y) 
            acs.move(6, self.insertPosZ - stage2z)
        
            self.prevButton = "A1"
            self.curButton = "A1"
            self.currentwellnote.SetValue(self.curButton)
            
        elif self.ReceiveMode == "96 wells":
            acs.getPosition2();
            stage2x, stage2y, stage2z = acs.getPosition2()
            acs.move(4, -2.9 - stage2x)
            acs.move(5, 12.54 - stage2y)
            acs.move(6, 23.4 - stage2z)
            self.prevButton = "A1"
            self.curButton = "A1"
            self.currentwellnote.SetValue(self.curButton)
        else:
            print "[error] wrong recieve mode";
            
        self.stage2lock = 0
        acs.MotionEnd();
        
    def Retrieve(self,event):
        if self.ReceiveMode == "single cap":
            if self.stage2lock == 0:
                acs.move(6,-15)
                acs.move(5,30)
        elif self.ReceiveMode == "96 caps":
            acs.getPosition2()
            stage2x, stage2y, stage2z = acs.getPosition2()
            acs.move(4, 50.1 - stage2x)
            acs.move(5, 73.54 - stage2y)
            acs.move(6, -3.063 - stage2z)
            self.prevButton = "A1"
            self.curButton = "A1"
            self.currentwellnote.SetValue(self.curButton)
        elif self.ReceiveMode == "96 wells":
            acs.getPosition2()
            stage2x, stage2y, stage2z = acs.getPosition2()
            acs.move(4, 50.1 - stage2x)
            acs.move(5, 73.54 - stage2y)
            acs.move(6, -3.063 - stage2z)
            self.prevButton = "A1"
            self.curButton = "A1"
            self.currentwellnote.SetValue(self.curButton)
        else:
            print "[error] wrong recieve mode";
            
        self.stage2lock = 1
        acs.MotionEnd();

##Roughness       

    def Roughness(self,event):
        if event.GetSelection() == 0:
            self.Ro = 1 #0.5
            self.Ro1 = 500 #50
            self.Ro2 = 21870
            self.Ro3 = 10
            self.Roslider.SetValue(1000)
        elif event.GetSelection() == 1:
            self.Ro = 0.01 #0.05
            self.Ro1 = 5
            self.Ro2 = 218.7 #10935
            self.Ro3 = 0.1 #3
            self.Roslider.SetValue(10)
        elif event.GetSelection() == 2:
            self.Ro = 0.001
            self.Ro1 = 0.5
            self.Ro2 = 21.87 #10935/2
            self.Ro3 = 0.01 #0.5
            self.Roslider.SetValue(1)


    def Roslide(self,event):
        self.Rough = int(self.Roslider.GetValue())
        self.Ro = 0.001*self.Rough
        self.Ro1 = 0.5*self.Rough #0.05
        self.Ro2 = 21.87*self.Rough
        self.Ro3 = 0.01*self.Rough

    def RoSet(self,event):
        self.Rough = int(self.RoSetText.GetValue())
        self.Ro = 0.001*self.Rough
        self.Ro1 = 0.5*self.Rough #0.05
        self.Ro2 = 21.87*self.Rough
        self.Ro3 = 0.01*self.Rough
        self.Roslider.SetValue(self.Rough)
        #print self.Rough

    def z1moveup(self,event):
        AF.write('#MV %s\r\n'%(str(int(int(self.Ro1)*12.72))))
        
    def z1movedown(self,event):
        AF.write('#MV %s\r\n'%(str(int(int(-1*self.Ro1)*12.72))))

    def z1moveWheel(self, event):
        wheelDelta = event.GetWheelDelta()  #usually 120
        wheelRotation = event.GetWheelRotation() #sign indicate direction, value indicate delta
##        print "wheelDelta: ", wheelDelta
##        print "wheelRotation: ", wheelRotation
        AF.write('#MV %s\r\n'%(str(int(int(self.Ro1 * wheelRotation / 120.0)*12.72))))


    def z2moveup(self,event):
        acs.move(6,self.Ro)
        
    def z2movedown(self,event):
        acs.move(6,-1*self.Ro)

##    def WellSelection(self,event):
##        self.wellindexbef = self.wellindex
##        self.wellindex = int(event.GetSelection())+1
##        acs.move(5,9*(self.wellindex - self.wellindexbef))
##        
    def SetReference1(self,event):
        self.ref1x,self.ref1y = acs.getPosition()
        self.ref1y *= -1
    

    def SetReference2(self,event):
        self.ref2x,self.ref2y = acs.getPosition()
        self.ref2y *= -1

    def Setoffset1(self,event):
        self.Offsetx1, self.Offsety1 = acs.getPosition()

    def Setoffset2(self,event):
        self.Offsetx2, self.Offsety2 = acs.getPosition()

    def OffsetReset(self,event):
        self.Offsetx1, self.Offsety1, self.Offsetx2, self.Offsety2 = 0,0,0,0

    def RefSet(self,event):
        self.oRefx1 = float(self.refNote1.GetValue().split()[0])
        self.oRefy1 = float(self.refNote1.GetValue().split()[1])
        self.oRefx2 = float(self.refNote2.GetValue().split()[0])
        self.oRefy2 = float(self.refNote2.GetValue().split()[1])

        self.scale = math.sqrt(pow((self.ref2y-self.ref1y),2)+pow((self.ref2x-self.ref1x),2))/math.sqrt(pow((self.oRefy2-self.oRefy1),2)+pow((self.oRefx2-self.oRefx1),2))


        self.cosTheta = (self.ref1y-self.ref2y+(self.ref1x-self.ref2x)*(self.oRefx1-self.oRefx2)/(self.oRefy1-self.oRefy2))  /  (pow((self.oRefx1-self.oRefx2),2)/(self.oRefy1-self.oRefy2)+self.oRefy1-self.oRefy2)/self.scale
        

        try:self.sinTheta = math.sqrt(1-pow(self.cosTheta,2))
        except: self.sinTheta = float(0)

        self.Cx = self.ref1x - (self.scale*self.cosTheta*self.oRefx1 - self.scale*self.sinTheta*self.oRefy1)
        self.Cy = self.ref1y - (self.scale*self.sinTheta*self.oRefx1 + self.scale*self.cosTheta*self.oRefy1)



    def Conversion(self,x,y):
        New = matrix([[self.scale*self.cosTheta, -self.scale*self.sinTheta],
                      [self.scale*self.sinTheta, self.scale*self.cosTheta]]) * matrix([[x],[y]]) + matrix([[self.Cx], [self.Cy]])
        return New




    
    def LED_off(self):
        il_4ch.write('1STA\r\n')
        if self.rBFindex == 1 : il_4ch.write('1IOF\r\n')
        il_4ch.write('2STA\r\n')
        if self.rBFindex == 1 : il_4ch.write('2IOF\r\n')
        il_4ch.write('3STA\r\n')
        if self.rBFindex == 1 : il_4ch.write('3IOF\r\n')
        il_4ch.write('4STA\r\n')
        if self.rBFindex == 1 : il_4ch.write('4IOF\r\n')

    def GetPositionAll(self,event):
        print "(sample x, sample y, lens, 96well x, 96well y, 96well z) = " + str(acs.getPosition_all())
        print "[slit x, slity, filter, slit theta] = " + str(getFourAxisPos())
        print "AF lens z axis: " + str(getAFpos())

    def SetInsertPosition(self, event):
        acs.getPosition2(); #first getPosition call returns strange value (stage2x)
        stage2x, stage2y, stage2z = acs.getPosition2()
        self.insertPosX = stage2x
        self.insertPosY = stage2y
        self.insertPosZ = stage2z
        print "Insert Positon Reset"
        


## Laser function
    def lasershot(self,event):
        self.laser.TTL()




if __name__ == '__main__':
    app = MyGUIApp()
    app.MainLoop()
##    app.Quit()

if DebugMode == "run mode":
    il_2ch.close()
    AF.close()
    il_4ch.close()
    FourAxis.close()
    acs.close()
##    acs=LPC_ACS.ACS()
##    acs.close()

